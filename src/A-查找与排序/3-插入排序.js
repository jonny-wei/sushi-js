/**
 * 插入排序 Insertion Sort
 *
 * 工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
 * 插入排序在实现上，通常采用 in-place 内排序（即只需用到 O(1) 的额外空间的排序），
 * 因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
 *
 * 插入排序和冒泡排序一样，也有一种优化算法，叫做二分插入排序。
 * 二分插入排序（Binary Insertion Sort）是对插入排序算法的一种改进。
 * 所谓插入排序，就是不断的依次将元素插入前面已排好序的序列中。
 *
 * 二分插入排序与直接插入排序算法原理相同。只是，在向已排序的数据中插入数据时，采用二分查找（二分查找）。
 * 先取已经排序的序列的中间元素，与待插入的数据进行比较，如果中间元素的值大于待插入的数据，
 * 那么待插入的数据属于数组的前半部分，否则属于后半部分。
 * 依此类推，不断缩小范围，确定要插入的位置。
 * 
 * 二分插入排序仅仅减少了比较元素的次数，约为 O(nLogn)，该比较次数与待排序表的初始状态无关，仅取决于表中的元素的个数 n。
 * 而元素的移动次数没有改变，它依赖于待排序表的初始状态，因此二分插入排序的时间复杂度为 O(n^2)。
 *
 * 算法原理
 *
 * 1. 从第一个元素开始，该元素可以认为已排序
 * 2. 取出下一个元素，在已经排序区间中从后向前扫描
 * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
 * 4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
 * 5. 将新元素插入到该位置后
 * 6. 重复步骤 2-5
 *
 * 算法复杂度
 * 
 * 平均时间复杂度：O(n^2)
 * 空间复杂度：O(1)
 * 稳定性：稳定
 * 排序方式：In-place 内排
 *
 */

/**
 * 方法一 直接插入排序(简单插入)
 */

const insertionSort = function (arr) {
  const len = arr.length;
  let cur = null; // 当前待插入值

  for (let i = 1; i < len; i++) {
    cur = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > cur) {
      arr[j + 1] = arr[j]; //将当前扫描的值向后挪动
      j--; // 扫描指针向前移动
    }
    // 插入
    arr[j + 1] = cur;
  }

  return arr;
};

/**
 * 方法二 二分插入排序(折半查找插入)
 * @param {*} arr
 * @returns
 */
const insertionSort = function (arr) {
  for (let i = 1; i < arr.length; i++) {
    let left = 0;
    let right = i - 1;
    let cur = arr[i];
    // 二分查找(查找已排序区间中当前元素的插入位置)
    while (left <= right) {
      let middle = Math.floor((left + right) / 2);
      if (cur < arr[middle]) {
        right = middle - 1;
      } else {
        left = middle + 1;
      }
    }
    /**
     * 二分查找只是提高了当前元素的插入位置查找
     * 但是找到位置后还需要通过移动数组来插入元素
     */
    for (let j = i - 1; j >= left; j--) {
      arr[j + 1] = arr[j];
    }
    // 插入
    arr[left] = cur;
  }

  return arr;
};
