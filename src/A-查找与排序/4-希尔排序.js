/**
 * 希尔排序 Shell Sort
 *
 * 又称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是不稳定排序算法
 *
 * 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
 * 1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
 * 2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
 *
 * 希尔排序的基本思想是：
 * 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，
 * 待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。
 *
 * 算法原理：
 * 先将整个待排元素序列分割成若干个子序列（由相隔某个 增量 的元素组成的）分别进行直接插入排序，
 * 然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，
 * 再对全体元素进行一次直接插入排序。
 * 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，
 * 因此希尔排序在时间效率上比前两种方法有较大提高。
 *
 * 1. 先取一个小于 n 的整数 d1 作为第一个增量，把文件的全部记录分成 d1 个组
 * 2. 所有距离为 d1 的记录放在同一个组中，在各组内进行直接插入排序
 * 3. 取第二个增量 d2 小于 d1 重复上述的分组和排序，直至所取的增量 dt = 1
 *
 * 算法复杂度
 * 平均时间复杂度：O(nlogn)
 * 空间复杂度：O(1) 原地排序
 * 稳定性：不稳定
 *
 * 希尔排序的效率取决于增量值 gap 的选取，时间复杂度并不是一个定值。
 * 开始时，gap 取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；
 * 其次，gap 值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，
 * 所以继承了直接插入排序的优点，能以近线性的速度排好序。
 *
 */

const shellSort = function (arr) {
  let len = arr.length;
  let temp = null;
  let gap = Math.floor(len / 2);

  while (gap > 0) {
    for (let i = gap; i < len; i++) {
      temp = arr[i]; // 先拿到索引为 gap 的元素
      let j = i - gap; // 再拿 temp 前面间隔 gap 的元素
      // 交换
      while (j >= 0 && arr[j] > temp) {
        arr[j + gap] = arr[j];
        j -= gap;
      }
      arr[j + gap] = temp;
    }
    gap = Math.floor(gap / 2);
  }

  return arr;
};
